using ToSic.Sxc.Data;
using ToSic.Sxc.Data.Internal;

// ReSharper disable once CheckNamespace
namespace Custom.Data;


/// <summary>
/// Base class for **plain** custom data models and can be used in Razor Components.
/// 
/// This is much lighter than the <see cref="CustomItem"/> which also wraps data, as it doesn't have any predefined properties and doesn't have the <see cref="ITypedItem"/> APIs.
/// </summary>
/// <example>
///
/// Usage ca. like this:
///
/// 1. A custom data model in `AppCode.Data` which inherits from this class (usually generated by 2sxc Copilot)
/// 2. Razor code which uses it to convert typed items into this custom data model
/// 
/// Example trivial custom **plain** data model:
/// ```c#
/// namespace AppCode.Data
/// {
///   class MyPerson : CustomModelOfItem
///   {
///     public string Name => _item.String("Name");
///   }
/// }
/// ```
///
/// Example usage in Razor:
///
/// ```razor#
/// @inherits Custom.Hybrid.RazorTyped
/// @using AppCode.Data
/// @{
///   var person = As&lt;MyPerson&gt;(MyItem);
/// }
/// <span>@person.Name</span>
/// ```
/// </example>
/// <remarks>
/// - Released in v19.01 (BETA)
/// </remarks>
[InternalApi_DoNotUse_MayChangeWithoutNotice("Still beta, name may change to CustomModelOfItem or something")]
public abstract partial class DataModel: IDataModelOf<IEntity>, IDataWrapperForType, /*ICanBeItem,*/ ICanBeEntity //, IHasPropLookup
{
    #region Explicit Interfaces for internal use - Setup, etc.

    void IDataModelOf<IEntity>.Setup(IEntity baseItem)
        => _data = baseItem;

    /// <inheritdoc />
    string IDataWrapperForType.ForContentType
        => GetType().Name;

    ///// <summary>
    ///// The actual item which is being wrapped, in rare cases where you must access it from outside.
    /////
    ///// It's only on the explicit interface, so it is not available from outside or inside, unless you cast to it.
    ///// Goal is that inheriting classes don't access it to keep API surface small.
    ///// </summary>
    //ITypedItem ICanBeItem.Item => Item;

    /// <summary>
    /// This is necessary so the object can be used in places where an IEntity is expected,
    /// like toolbars.
    ///
    /// It's an explicit interface implementation, so that the object itself doesn't broadcast this.
    /// </summary>
    [PrivateApi]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    IEntity ICanBeEntity.Entity => _data;

    //IBlock ICanBeItem.TryGetBlockContext() => Item.TryGetBlockContext();

    //IPropertyLookup IHasPropLookup.PropertyLookup => _propLookup ??= ((IHasPropLookup)((ICanBeItem)this).Item).PropertyLookup;
    //private IPropertyLookup _propLookup;

    #endregion

    /// <summary>
    /// The item - for inheriting classes to access.
    /// </summary>
    /// <remarks>
    /// This property is protected, not public, as it should only be used internally.
    /// </remarks>
    // ReSharper disable once InconsistentNaming
    protected internal IEntity _data { get; private set; }

    /// <summary>
    /// Override ToString to give more information about the current object
    /// </summary>
    public override string ToString() 
        => $"{nameof(DataModelOfItem)} Data Model {GetType().FullName} " + (_data == null ? "without backing data (null)" : $"for id:{_data.EntityId} ({_data})");


    #region As...

    /// <summary>
    /// Convert an Entity or TypedItem into a strongly typed object.
    /// Typically, the type will be from your `AppCode.Data`.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="item"></param>
    /// <returns></returns>
    protected T As<T>(ITypedItem item)
        where T : class, IDataModel, new()
        => CodeDataFactory.AsCustomFrom<T, ITypedItem>(item);

    protected T As<T>(IEntity item)
        where T : class, IDataModel, new()
        => CodeDataFactory.AsCustomFrom<T, IEntity>(item);

    /// <summary>
    /// Convert a list of Entities or TypedItems into a strongly typed list.
    /// Typically, the type will be from your `AppCode.Data`.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="source"></param>
    /// <param name="protector"></param>
    /// <param name="nullIfNull"></param>
    /// <returns></returns>
    protected IEnumerable<T> AsList<T>(IEnumerable<ITypedItem> source, NoParamOrder protector = default, bool nullIfNull = false)
        where T : class, IDataModel, new()
        => (source ?? (nullIfNull ? null : []))?.Select(CodeDataFactory.AsCustomFrom<T, ITypedItem>).ToList();

    protected IEnumerable<T> AsList<T>(IEnumerable<IEntity> source, NoParamOrder protector = default, bool nullIfNull = false)
        where T : class, IDataModel, new()
        => (source ?? (nullIfNull ? null : []))?.Select(CodeDataFactory.AsCustomFrom<T, IEntity>).ToList();

    #endregion

}