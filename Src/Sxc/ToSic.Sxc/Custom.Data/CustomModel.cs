using ToSic.Sxc.Blocks.Internal;
using ToSic.Sxc.Data;
using ToSic.Sxc.Data.Internal;

// ReSharper disable once CheckNamespace
namespace Custom.Data;


/// <summary>
/// Base class for **plain** custom data models and can be used in Razor Components.
/// 
/// This is much lighter than the <see cref="CustomItem"/> which also wraps data, as it doesn't have any predefined properties and doesn't have the <see cref="ITypedItem"/> APIs.
/// </summary>
/// <example>
///
/// Usage ca. like this:
///
/// 1. A custom data model in `AppCode.Data` which inherits from this class (usually generated by 2sxc Copilot)
/// 2. Razor code which uses it to convert typed items into this custom data model
/// 
/// Example trivial custom **plain** data model:
/// ```c#
/// namespace AppCode.Data
/// {
///   class MyPerson : CustomModel
///   {
///     public string Name => _item.String("Name");
///   }
/// }
/// ```
///
/// Example usage in Razor:
///
/// ```razor#
/// @inherits Custom.Hybrid.RazorTyped
/// @using AppCode.Data
/// @{
///   var person = As&lt;MyPerson&gt;(MyItem);
/// }
/// <span>@person.Name</span>
/// ```
/// </example>
/// <remarks>
/// - Released in v19.01 (BETA)
/// </remarks>
[InternalApi_DoNotUse_MayChangeWithoutNotice("Still beta, name may change to CustomModelOfItem or something")]
public abstract partial class CustomModel : IDataModelOf<ITypedItem>, IDataWrapperForType, ICanBeItem, ICanBeEntity //, IHasPropLookup
{
    #region Explicit Interfaces for internal use - Setup, etc.

    void IDataModelOf<ITypedItem>.Setup(ITypedItem baseItem)
        => Item = baseItem;

    /// <inheritdoc />
    string IDataWrapperForType.ForContentType
        => GetType().Name;

    /// <summary>
    /// The actual item which is being wrapped, in rare cases where you must access it from outside.
    ///
    /// It's only on the explicit interface, so it is not available from outside or inside, unless you cast to it.
    /// Goal is that inheriting classes don't access it to keep API surface small.
    /// </summary>
    ITypedItem ICanBeItem.Item => Item;

    /// <summary>
    /// This is necessary so the object can be used in places where an IEntity is expected,
    /// like toolbars.
    ///
    /// It's an explicit interface implementation, so that the object itself doesn't broadcast this.
    /// </summary>
    [PrivateApi]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    IEntity ICanBeEntity.Entity => Item.Entity;

    IBlock ICanBeItem.TryGetBlockContext() => Item.TryGetBlockContext();

    //IPropertyLookup IHasPropLookup.PropertyLookup => _propLookup ??= ((IHasPropLookup)((ICanBeItem)this).Item).PropertyLookup;
    //private IPropertyLookup _propLookup;

    #endregion

    /// <summary>
    /// The item - for inheriting classes to access.
    /// </summary>
    /// <remarks>
    /// This property is protected, not public, as it should only be used internally.
    /// </remarks>
    protected internal ITypedItem Item { get; private set; }

    /// <summary>
    /// Override ToString to give more information about the current object
    /// </summary>
    public override string ToString() 
        => $"{nameof(CustomModel)} Data Model {GetType().FullName} " + (Item == null ? "without backing data (null)" : $"for id:{Item.Id} ({Item})");


    //#region As...

    ///// <summary>
    ///// Convert an Entity or TypedItem into a strongly typed object.
    ///// Typically, the type will be from your `AppCode.Data`.
    ///// </summary>
    ///// <typeparam name="T"></typeparam>
    ///// <param name="item"></param>
    ///// <returns></returns>
    ///// <remarks>
    ///// New in v17.03
    ///// </remarks>
    //protected T As<T>(ITypedItem item)
    //    where T : class, ITypedItemWrapper16, ITypedItem, new()
    //    => CodeDataFactory.AsCustomFromItem<T>(item);

    ///// <summary>
    ///// Convert a list of Entities or TypedItems into a strongly typed list.
    ///// Typically, the type will be from your `AppCode.Data`.
    ///// </summary>
    ///// <typeparam name="T"></typeparam>
    ///// <param name="source"></param>
    ///// <param name="protector"></param>
    ///// <param name="nullIfNull"></param>
    ///// <returns></returns>
    ///// <remarks>
    ///// New in v17.03
    ///// </remarks>
    //protected IEnumerable<T> AsList<T>(IEnumerable<ITypedItem> source, NoParamOrder protector = default, bool nullIfNull = false)
    //    where T : class, ITypedItemWrapper16, ITypedItem, new()
    //    => (source ?? (nullIfNull ? null : []))?.Select(CodeDataFactory.AsCustomFromItem<T>).ToList();

    //#endregion

}