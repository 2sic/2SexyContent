using ToSic.Sxc.Data;

// ReSharper disable once CheckNamespace
namespace Custom.Data;


/// <summary>
/// Base class for **plain** custom data models and can be used in Razor Components.
/// 
/// This is much lighter than the <see cref="CustomItem"/> which also wraps data, as it doesn't have any predefined properties and doesn't have the <see cref="ITypedItem"/> APIs.
/// </summary>
/// <example>
///
/// Usage ca. like this:
///
/// 1. A custom data model in `AppCode.Data` which inherits from this class (usually generated by 2sxc Copilot)
/// 2. Razor code which uses it to convert typed items into this custom data model
/// 
/// Example trivial custom **plain** data model:
/// ```c#
/// namespace AppCode.Data
/// {
///   class MyPerson : CustomModel
///   {
///     public string Name => _item.String("Name");
///   }
/// }
/// ```
///
/// Example usage in Razor:
///
/// ```razor#
/// @inherits Custom.Hybrid.RazorTyped
/// @using AppCode.Data
/// @{
///   var person = As&lt;MyPerson&gt;(MyItem);
/// }
/// <span>@person.Name</span>
/// ```
/// </example>
/// <remarks>
/// - Released in v19.01 (BETA)
/// </remarks>
[PublicApi]
public abstract partial class CustomModel : ITypedItemWrapper //, IHasPropLookup
{
    #region Explicit Interfaces for internal use - Setup, etc.

    /// <inheritdoc />
    void ITypedItemWrapper.Setup(ITypedItem baseItem)
        => _item = baseItem;

    /// <inheritdoc />
    string ITypedItemWrapper.ForContentType
        => GetType().Name;

    ///// <summary>
    ///// The actual item which is being wrapped, in rare cases where you must access it.
    /////
    ///// It's only on the explicit interface, so it is not available from outside or inside, unless you cast to it.
    ///// Goal is that inheriting classes don't access it to keep API surface small.
    ///// </summary>
    //ITypedItem ICanBeItem.Item => _item;

    ///// <summary>
    ///// This is necessary so the object can be used in places where an IEntity is expected,
    ///// like toolbars.
    /////
    ///// It's an explicit interface implementation, so that the object itself doesn't broadcast this.
    ///// </summary>
    //[PrivateApi]
    //[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    //IEntity ICanBeEntity.Entity => _item.Entity;

    //IBlock ICanBeItem.TryGetBlockContext() => _item.TryGetBlockContext();

    //IPropertyLookup IHasPropLookup.PropertyLookup => _propLookup ??= ((IHasPropLookup)((ICanBeItem)this).Item).PropertyLookup;
    //private IPropertyLookup _propLookup;

    #endregion

    /// <summary>
    /// The item - for inheriting classes to access.
    /// </summary>
    /// <remarks>
    /// This property is protected, not public, as it should only be used internally.
    /// It uses an unusual name _item to avoid naming conflicts with properties generated in inheriting classes.
    /// </remarks>
    // ReSharper disable once InconsistentNaming
#pragma warning disable IDE1006
    protected internal ITypedItem _item { get; private set; }
#pragma warning restore IDE1006

    /// <summary>
    /// Override ToString to give more information about the current object
    /// </summary>
    public override string ToString() 
        => $"{nameof(CustomModel)} Data Model {GetType().FullName} " + (_item == null ? "without backing data (null)" : $"for id:{_item.Id} ({_item})");


    //#region As...

    ///// <summary>
    ///// Convert an Entity or TypedItem into a strongly typed object.
    ///// Typically, the type will be from your `AppCode.Data`.
    ///// </summary>
    ///// <typeparam name="T"></typeparam>
    ///// <param name="item"></param>
    ///// <returns></returns>
    ///// <remarks>
    ///// New in v17.03
    ///// </remarks>
    //protected T As<T>(ITypedItem item)
    //    where T : class, ITypedItemWrapper16, ITypedItem, new()
    //    => CodeDataFactory.AsCustomFromItem<T>(item);

    ///// <summary>
    ///// Convert a list of Entities or TypedItems into a strongly typed list.
    ///// Typically, the type will be from your `AppCode.Data`.
    ///// </summary>
    ///// <typeparam name="T"></typeparam>
    ///// <param name="source"></param>
    ///// <param name="protector"></param>
    ///// <param name="nullIfNull"></param>
    ///// <returns></returns>
    ///// <remarks>
    ///// New in v17.03
    ///// </remarks>
    //protected IEnumerable<T> AsList<T>(IEnumerable<ITypedItem> source, NoParamOrder protector = default, bool nullIfNull = false)
    //    where T : class, ITypedItemWrapper16, ITypedItem, new()
    //    => (source ?? (nullIfNull ? null : []))?.Select(CodeDataFactory.AsCustomFromItem<T>).ToList();

    //#endregion

}