using System;
using System.Collections.Generic;
using System.Linq;
using ToSic.Eav.Context;
using ToSic.Eav.Data;
using ToSic.Eav.Data.PropertyLookup;
using ToSic.Eav.Plumbing;
using ToSic.Lib.DI;
using ToSic.Lib.Documentation;
using ToSic.Lib.Helpers;
using ToSic.Lib.Logging;
using ToSic.Sxc.Adam;
using ToSic.Sxc.Code;
using ToSic.Sxc.Context;
using ToSic.Sxc.Services;

namespace ToSic.Sxc.Data.AsConverter
{
    // todo: make internal once we have an interface
    public partial class AsConverterService: ServiceForDynamicCode
    {
        private readonly LazySvc<DynamicEntity.MyServices> _dynamicEntityDependenciesLazy;
        private readonly LazySvc<AdamManager> _adamManagerLazy;
        private readonly LazySvc<IContextOfApp> _contextOfAppLazy;

        public AsConverterService(
            LazySvc<DynamicEntity.MyServices> dynamicEntityDependencies,
            LazySvc<AdamManager> adamManager,
            LazySvc<IContextOfApp> contextOfApp) : base("Sxc.AsConv")
        {
            ConnectServices(
                _dynamicEntityDependenciesLazy = dynamicEntityDependencies,
                _adamManagerLazy = adamManager,
                _contextOfAppLazy = contextOfApp
            );
        }

        public void SetFallbacks(ISite site, int? compatibility = default, AdamManager adamManagerPrepared = default)
        {
            _siteOrNull = site;
            _compatibility = compatibility;
            _adamManagerPrepared = adamManagerPrepared;
        }

        private ISite _siteOrNull;
        private int? _compatibility;
        private AdamManager _adamManagerPrepared;


        #region AdamManager - also depends on DynamicEntityService

        /// <summary>
        /// Special helper - if the DynamicCode is generated by the service or used in a WebApi there is no block, but we can figure out the context.
        /// </summary>
        /// <returns></returns>
        /// <exception cref="Exception"></exception>
        private AdamManager GetAdamManager()
        {
            // if this was initialized with an ADAM manager, use that
            if (_adamManagerPrepared != null) return _adamManagerPrepared;

            // If we don't even have a _DynCodeRoot (eg. when exporting from a neutral WebAPI)
            if (_DynCodeRoot is null)
                throw new Exception($"Can't create App Context for {nameof(AdamManager)} in {nameof(AsConverterService)} - no block, no App");

            IContextOfApp contextOfApp = _DynCodeRoot.Block?.Context;
            // TODO: @2dm - find out / document why this could even be null
            if (contextOfApp == null)
            {
                if (_DynCodeRoot.App == null)
                    throw new Exception("Can't create App Context for ADAM - no block, no App");
                contextOfApp = _contextOfAppLazy.Value;
                contextOfApp.ResetApp(_DynCodeRoot.App);
            }

            return _adamManagerLazy.Value.Init(contextOfApp, this, _DynCodeRoot.CompatibilityLevel);
        }
        public AdamManager AdamManager => _admMng.Get(GetAdamManager);
        private readonly GetOnce<AdamManager> _admMng = new GetOnce<AdamManager>();

        #endregion

        #region DynamicEntityServices

        public DynamicEntity.MyServices DynamicEntityServices => _dynamicEntityServices.Get(Log, l =>
        {
            var rawServices = _dynamicEntityDependenciesLazy.Value;

            // Scenario 1: Get everything from the DynamicCodeRoot
            if (_DynCodeRoot != null)
                return rawServices.Init(
                    _DynCodeRoot.Block,
                    _DynCodeRoot.CmsContext.SafeLanguagePriorityCodes(),
                    Log,
                    this,
                    _DynCodeRoot.CompatibilityLevel,
                    _DynCodeRoot.GetKit<ServiceKit14>
                    // Important: Get AdamManager must be a function, as it also depends on this DynEntServices
                    // This is not the ideal solution, should probably be improved...
                    //() => AdamManager
                    );

            // If we don't have a DynCodeRoot, try to generate the language codes and compatibility
            // There are cases where these were supplied (using the SetFallbacks)
            // but there are cases where none of this is known
            return rawServices.Init(null, _siteOrNull.SafeLanguagePriorityCodes(), Log, this, compatibility: _compatibility ?? Constants.CompatibilityLevel10);
        });
        private readonly GetOnce<DynamicEntity.MyServices> _dynamicEntityServices = new GetOnce<DynamicEntity.MyServices>();

        #endregion

        public DynamicJacketBase AsDynamicFromJson(string json, string fallback = default) => DynamicJacket.AsDynamicJacket(json, fallback, Log);

        public IEntity AsEntity(object dynamicEntity) => dynamicEntity as IEntity ?? ((ICanBeEntity)dynamicEntity).Entity;

        #region ADAM / Folder

        public IFolder Folder(ICanBeEntity item, string fieldName) => AdamManager.Folder(item.Entity, fieldName);

        #endregion



        [PrivateApi]
        public ITypedStack MergeTyped(params object[] objects)
        {
            if (!objects.SafeAny()) return null;
            // if (objects.Length == 1) return AsTypedInternal(objects[0]);
            // New case: many items found, must create a stack
            var sources = objects
                .Select(e => e as IPropertyLookup)
                .Where(e => e != null)
                .Select(e => new KeyValuePair<string, IPropertyLookup>(null, e))
                .ToList();
            return new DynamicStack(Eav.Constants.NullNameId, DynamicEntityServices, sources);
        }


        internal ITypedRead AsTypedInternal(object dynObject)
        {
            var l = Log.Fn<ITypedRead>();
            switch (dynObject)
            {
                case null:
                    return l.Return(AsDynamicFromJson(null), "null");
                case string strObject:
                    return l.Return(AsDynamicFromJson(strObject), "string");
                case IDynamicEntity dynEnt:
                    return l.Return(dynEnt, "DynamicEntity");
                // New case - should avoid re-converting dynamic json, DynamicStack etc.
                case ISxcDynamicObject sxcDyn:
                    return l.Return(sxcDyn, "Dynamic Something");
                case IEntity entity:
                    return l.Return(new DynamicEntity(entity, DynamicEntityServices), "IEntity");
                //case DynamicObject typedDynObject:
                //    return wrapLog.Return(typedDynObject, "DynamicObject");
                default:
                    // Check value types - note that it won't catch strings, but these were handled above
                    //if (dynObject.GetType().IsValueType) return wrapLog.Return(dynObject, "bad call - value type");

                    // 2021-09-14 new - just convert to a DynamicReadObject
                    var result = DynamicHelpers.WrapIfPossible(dynObject, true, true, false);
                    if (result is ITypedRead resTyped) return l.Return(resTyped, "converted to dyn-read");

                    //// Note 2dm 2021-09-14 returning the original object was actually the default till now.
                    //// Unknown conversion, just return the original and see what happens/breaks
                    //// probably not a good solution
                    //return wrapLog.Return(dynObject, "unknown, return original");
                    return l.Return(null, "unknown, return original");
            }
        }
    }
}
